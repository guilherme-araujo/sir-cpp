#include <iostream>
#include <unistd.h>
#include <thread>
#include <future>
#include "utils/graphParser.h"
#include "simulation.h"

using namespace std;

void waitupdate(){
	usleep(10000);
}

string str_nbuild = "-v";
string nbuild = "20200913.001";

int main(int argc, char* argv[]){

	//Default simulation values
	int samples = 1;	
	int threads = 1;

	int cycles = 1000;
	bool stateHistory = true;
	int infectedTime = 30;	
	bool printPartials = false;
	int sampleid = 0;
	double spreadChance = 0.1;

	//Simulation values parsing from argv
	string arg_samples = "samples";
	string arg_threads = "threads";

	string arg_cycles = "cycles";
	string arg_stateHistory = "stateHistory";
	string arg_infectedTime = "infectedTime";
	string arg_sampleid = "sampleId";
	string arg_printPartials = "printPartials";
	string arg_spreadChance = "spreadChance";


	for(int i = 1; i < argc; i+=2){
		if(str_nbuild.compare(argv[i])==0){
			cout<<nbuild<<endl;
			return 0;
		}else if(arg_samples.compare(argv[i])==0){
			samples = stoi(argv[i+1]);
		}else if(arg_threads.compare(argv[i])==0){
			threads = stoi(argv[i+1]);
		}else if(arg_cycles.compare(argv[i])==0){
			cycles = stoi(argv[i+1]);
		}else if (arg_stateHistory.compare(argv[i])==0){
			stateHistory = stoi(argv[i+1]);
		}else if(arg_infectedTime.compare(argv[i])==0){
			infectedTime = stoi(argv[i+1]);
		}else if (arg_sampleid.compare(argv[i])==0){
			sampleid = stoi(argv[i+1]);
		}else if (arg_printPartials.compare(argv[i])==0){
			printPartials = stoi(argv[i+1]);
		}else if (arg_spreadChance.compare(argv[i])==0){
			spreadChance = stod(argv[i+1]);
		}
		
	}
	
	//Parse graph generated by python script or another source
	Parser p;
	GsopGraph *g = p.parse("graph.txt");
	
	
	SimulationData simulationData;

	simulationData.spreadChance = spreadChance;
	simulationData.initialPop = g->nodes.size();
	simulationData.cycles = cycles;
	simulationData.stateHistory = stateHistory;
	simulationData.infectedTime = infectedTime;
	simulationData.printPartials = printPartials;
	simulationData.sampleid = sampleid;
	simulationData.g = g;

	

	//Launch simulation threads according to number of samples
	vector<thread> tl;
	tl.resize(threads);
	vector<bool> tb; //false as not running
	tb.resize(threads);

	int scount = 0;

	vector< future<bool> >fut;
	fut.resize(threads);

	while(true){
		int ti = 0;

		for(ti = 0; ti < threads; ti++){

			if(!tb[ti] && scount!=samples){
				simulationData.sampleid = scount++;

				fut[ti] = async(Simulation::simulationV1,simulationData, ti);

				tb[ti] = true;
				
			}

			if(tb[ti]==true){
				if(fut[ti].wait_for(chrono::seconds(0))==future_status::ready){
					fut[ti].get();
					tb[ti] = false;
				}

			}

		}
		if(scount==samples){
			bool allover = true;
			for(ti = 0; ti < threads; ti++){
				if(tb[ti]){
					allover = false;
					break;
				}
			}
			if(allover) break;
		}

		thread wait = thread(waitupdate);
		wait.join();

	}

    return 0;
}
